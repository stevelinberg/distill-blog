---
title: "Useful R tidbits: Social Networks"
description: |
  Tasty R snacks that do useful things in Social Networks
author:
  - name: Steve Linberg
    url: {}
date: 2022-02-08
output:
  distill::distill_article:
    self_contained: false
    toc: true
categories:
  - r
  - social networks
---


```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = FALSE)
```

<p style="background: #eee">
[<i class="fas fa-home"></i>](/) &gt; Academics &gt; [PS753](../ps753/index.html)
&gt; Useful R tidbits
</p>

This document contains R snippets pertaining to work in the [Social Networks class](../ps753/index.html). There is also one for the [Machine Learning class](../ms797-useful-r-tidbits/index.html).

## Week 1 tutorial cheatsheet

||igraph|statnet|
|---|---|---|
|Count of vertices|`vcount()`||
|Count of edges|`ecount()`||
|Both||`print()`|
|Bipartite or single mode?|`is_bipartite()`|`print()`|
|Edges directed or undirected?|`is_directed()`|`print()`|
|Weighted? (or binary)|`is_weighted()`|`print()`|

vertex attribute
: vector of additional information about nodes in a network

edge attribute
: vector of additional information about the edges in a network

Q: how to get missing edge count in igraph?

||igraph|statnet|
|---|---|---|
|display vertex attributes|`vertex_attr_names()`|`list.vertex.attributes()`|
|display edge attributes|`edge_attr_names()`|`list.edge.attributes()`|

In igraph, attributes are accessed via `$`, using the `V` and `E` functions, 
as in:

```r
V(karate.ig)$name
E(karate.ig)$weight
```

In statnet, they are accessed via the `%v%` and `%e%` mechanisms, as in:

```r
karate.stat %v% "vertex.names"
karate.stat %e% "weight"
```

## Week 2 cheatsheet

A dyad census will count the reciprocal (`mut`), asymmetric (`asym`) and absent (`null`) dyads, based on directed graphs. In igraph:

```r
igraph::dyad.census(trade2007.ig)
$mut
[1] 11444

$asym
[1] 3148

$null
[1] 2244
```

In statnet:
```r
sna::dyad.census()
 [1]   6225  19035  40611   6442   7044  10097  55355  44966   9200   1876
[11] 146537  25578  17167  30894 225908 374449
```

Triad census is similar:

```r
igraph::triad_census(trade2007.ig)
```

```r
sna::triad.census(gotbook.stat, mode="graph")  # undirected
      
sna::triad.census(trade2007.stat)              # directed
      003   012   102 021D 021U 021C  111D  111U 030T 030C   201  120D
[1,] 6225 13655 26489 4225 4657 4821 34812 23635 4374  537 97088 15073
     120U  120C    210    300
[1,] 7947 14249 136169 283855

```

Note that the `statnet` version gives us information about the types of triads as column names in the matrix it returns. The `igraph` version also breaks them into the 16 categories, but returns them in a fixed order not detailed in its return value (described in its help documentation).

The total number of possible triads in a 298 vertex network is (298 x 297 x 296) / (3 x 2 x 1) - the 3 countdown comes from "triad". Quads would be (298 x 297 x 296 x 295) / (4 x 3 x 2 x 1).

## Transitivity

Transitivity is the percentage of potential connected triads - how many are complete. Basic way in igraph is `transitivity()`. The statnet version is `gtrans()`, but it only works in directed networks. `print()` will say whether the network is directed. (Note: in the tutorial, we see that the climate network IS directed, but it returns a different result than igraph: 0.627 vs 0.724. Not clear why. "it is calculating a transitivity score based on an understanding of network structure rooted in hierarchy")

Local transitivity is the `local clustering coefficient` - how many nodes of an ego are connected to each other. Have to unpack this, but the magic is:

```r
transitivity(gotbook.ig, type="local", 
  vids=V(gotbook.ig)[
  c("Petyr Baelish","Jon Snow", "Tyrion Lannister")]) 
```

The global clustering coefficient in igraph is

```r
transitivity(trade2007.ig, type="global")
[1] 0.8837142
```

The local coefficient is:

```r
transitivity(trade2007.ig, type="average")
[1] 0.8862707
```

Network transitivity in statnet is `gtrans()`:

```r
gtrans(trade2007.stat)
[1] 0.9993143
```

||igraph|statnet|
|---|---|---|
|global clustering coefficient|`transitivity(trade2007.ig,  type="global")`|`gtrans(trade2007.stat)` (directed only)|
|local clustering coefficient|`transitivity(trade2007.ig,  type="local")`|???|
|average local clustering coefficient|`transitivity(trade2007.ig,  type="average")`|???|

## Degree

`igraph::degree()` and `statnet::degree()`, and once again they give different results; igraph includes loops, statnet doesn't. Force igraph to ignore them with `loops = FALSE`. "Note that setting `diag=TRUE` in `sna::degree` does not guarantee equivalence as statnet only single counts the loops in a directed network, while igraph double-counts the loops."

igraph shows the node names, statnet doesn't.

Getting the degree of a particular set of nodes in `igraph`:

```r
igraph::degree(trade2007.ig, v = V(trade2007.ig)[c("China", "Canada", "United Kingdom", "Denmark")])
         China         Canada United Kingdom        Denmark 
           364            364            364            362 
```

### *Indegree* and *outdegree* calculations

||igraph|statnet|
|---|---|---|
|indegree|`igraph::degree(climate.ig,mode="in", loops = FALSE)`|`sna::degree(climate.stat, cmode="indegree")`|
|outdegree|`igraph::degree(climate.ig,mode="out", loops = FALSE)`|`sna::degree(climate.stat, cmode="outdegree")`|

Code from the tutorial to create `data.frame`s with degree statistics:

```r
#igraph:

trade2007.nodes <- data.frame(name = V(trade2007.ig)$name,
    totdegree = igraph::degree(trade2007.ig, loops = FALSE),
    indegree = igraph::degree(trade2007.ig, mode = "in", loops = FALSE),
    outdegree = igraph::degree(trade2007.ig, mode = "out", loops = FALSE))

#statnet version:

trade2007.nodes <- data.frame(name = trade2007.stat%v%"vertex.names",
    totdegree = sna::degree(trade2007.stat),
    indegree = sna::degree(trade2007.stat, cmode = "indegree"),
    outdegree = sna::degree(trade2007.stat, cmode = "outdegree"))
```
    
## Components

Shortest path length between 2 nodes: igraph `distances()` does this.

```r
distances(gotbook.ig,"Petyr Baelish","Robb Stark")
# Calculate distance using unweighted edges
distances(gotbook.ig,"Petyr Baelish","Robb Stark", weights=NA)
# list shortest paths between 2 nodes
all_shortest_paths(gotbook.ig,"Bronn","Varys", weights=NA)$res
#find average shortest path for network
average.path.length(gotbook.ig,directed=F)
```

Component structure and membership

```r
# What element are returned by components
names(igraph::components(gotbook.ig))

# Number of components
igraph::components(gotbook.ig)$no 

# Size of each component
igraph::components(gotbook.ig)$csize 

# retrieve the index of isolate nodes
# (nodes with component count of 1 from "components" above)
isolates(gotbook.stat)

# subset vertex.names attribute to get names of isolates
as.vector(gotbook.stat %v% 'vertex.names')[c(isolates(gotbook.stat))]
```

## Graph density

Note: `network.density()` (statnet) ignores edge values "at present".

```r
#get network density: igraph
graph.density(climate.ig)

## [1] 0.4117647

#get network density: statnet
network.density(climate.stat)

## [1] 0.399654
```

Adding `loops = TRUE` to `graph.density()` appears to fix the problem and gets the two packages to agree:

```r
#get network density without loops: igraph
graph.density(climate.ig, loops=TRUE)

## [1] 0.399654
```

*SO*, it's safest to always do either:
- `graph.density(climate.ig, loops=TRUE)` (igraph), OR
- `network.density(climate.stat)` (statnet)

In statnet, we can get network density with loops (nodes connecting to themselves) omitted:

```r
#get network density without loops: statnet
gden(climate.stat, diag=FALSE)

## [1] 0.3921569
```

## Network degree centralization

In `statnet`, call `centralization()` with the `degree` function and appropriate parameters for `degree` in the `cmode` argument:

```r
centralization(climate.stat, degree, cmode="indegree")
centralization(climate.stat, degree, cmode="outdegree")
centralization(climate.stat, degree, cmode="freeman") # default
```

Could also call it with other `sna` functions like `betweenness`, `closeness`; tutorial references `eigenvalue` but there is no such function in `sna`. `evcent` perhaps?

The `igraph` version uses `centr_degree()` and returns an object with several components, of which `centralization` is one:

```r
centr_degree(climate.ig, loops = FALSE, mode = "in")$centralization
centr_degree(climate.ig, loops = FALSE, mode = "out")$centralization
```



