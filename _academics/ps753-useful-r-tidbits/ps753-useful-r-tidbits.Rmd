---
title: "Useful R tidbits: Social Networks"
description: |
  Tasty R snacks that do useful things in Social Networks
author:
  - name: Steve Linberg
    url: {}
date: 2022-02-08
output:
  distill::distill_article:
    self_contained: false
    toc: true
categories:
  - r
  - social networks
---


```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = FALSE)
```

<p style="background: #eee">
[<i class="fas fa-home"></i>](/) &gt; Academics &gt; [PS753](../ps753/index.html)
&gt; Useful R tidbits
</p>

This document contains R snippets pertaining to work in the [Social Networks class](../ps753/index.html). There is also one for the [Machine Learning class](../ms797-useful-r-tidbits/index.html).

## Week 1 tutorial cheatsheet

||igraph|statnet|
|---|---|---|
|Count of vertices|`vcount()`||
|Count of edges|`ecount()`||
|Both||`print()`|
|Bipartite or single mode?|`is_bipartite()`|`print()`|
|Edges directed or undirected?|`is_directed()`|`print()`|
|Weighted? (or binary)|`is_weighted()`|`print()`|

vertex attribute
: vector of additional information about nodes in a network

edge attribute
: vector of additional information about the edges in a network

Q: how to get missing edge count in igraph?

||igraph|statnet|
|---|---|---|
|display vertex attributes|`vertex_attr_names()`|`list.vertex.attributes()`|
|display edge attributes|`edge_attr_names()`|`list.edge.attributes()`|

In igraph, attributes are accessed via `$`, using the `V` and `E` functions, 
as in:

```r
V(karate.ig)$name
E(karate.ig)$weight
```

In statnet, they are accessed via the `%v%` and `%e%` mechanisms, as in:

```r
karate.stat %v% "vertex.names"
karate.stat %e% "weight"
```

## Week 2 cheatsheet

A dyad census will count the reciprocal (`mut`), asymmetric (`asym`) and absent (`null`) dyads, based on directed graphs. In igraph:

```r
igraph::dyad.census(trade2007.ig)
$mut
[1] 11444

$asym
[1] 3148

$null
[1] 2244
```

In statnet:
```r
sna::dyad.census()
 [1]   6225  19035  40611   6442   7044  10097  55355  44966   9200   1876
[11] 146537  25578  17167  30894 225908 374449
```

Triad census is similar:

```r
igraph::triad_census(trade2007.ig)
```

```r
sna::triad.census(gotbook.stat, mode="graph")  # undirected
      
sna::triad.census(trade2007.stat)              # directed
      003   012   102 021D 021U 021C  111D  111U 030T 030C   201  120D
[1,] 6225 13655 26489 4225 4657 4821 34812 23635 4374  537 97088 15073
     120U  120C    210    300
[1,] 7947 14249 136169 283855

```

Note that the `statnet` version gives us information about the types of triads as column names in the matrix it returns. The `igraph` version also breaks them into the 16 categories, but returns them in a fixed order not detailed in its return value (described in its help documentation).

The total number of possible triads in a 298 vertex network is (298 x 297 x 296) / (3 x 2 x 1) - the 3 countdown comes from "triad". Quads would be (298 x 297 x 296 x 295) / (4 x 3 x 2 x 1).

## Transitivity

Transitivity is the percentage of potential connected triads - how many are complete. Basic way in igraph is `transitivity()`. The statnet version is `gtrans()`, but it only works in directed networks. `print()` will say whether the network is directed. (Note: in the tutorial, we see that the climate network IS directed, but it returns a different result than igraph: 0.627 vs 0.724. Not clear why. "it is calculating a transitivity score based on an understanding of network structure rooted in hierarchy")

Local transitivity is the `local clustering coefficient` - how many nodes of an ego are connected to each other. Have to unpack this, but the magic is:

```r
transitivity(gotbook.ig, type="local", 
  vids=V(gotbook.ig)[
  c("Petyr Baelish","Jon Snow", "Tyrion Lannister")]) 
```

The global clustering coefficient in igraph is

```r
transitivity(trade2007.ig, type="global")
[1] 0.8837142
```

The local coefficient is:

```r
transitivity(trade2007.ig, type="average")
[1] 0.8862707
```

Network transitivity in statnet is `gtrans()`:

```r
gtrans(trade2007.stat)
[1] 0.9993143
```

||igraph|statnet|
|---|---|---|
|global clustering coefficient|`transitivity(trade2007.ig,  type="global")`|`gtrans(trade2007.stat)` (directed only)|
|local clustering coefficient|`transitivity(trade2007.ig,  type="local")`|???|
|average local clustering coefficient|`transitivity(trade2007.ig,  type="average")`|???|

## Degree

`igraph::degree()` and `statnet::degree()`, and once again they give different results; igraph includes loops, statnet doesn't. Force igraph to ignore them with `loops = FALSE`. "Note that setting `diag=TRUE` in `sna::degree` does not guarantee equivalence as statnet only single counts the loops in a directed network, while igraph double-counts the loops."

igraph shows the node names, statnet doesn't.

Getting the degree of a particular set of nodes in `igraph`:

```r
igraph::degree(trade2007.ig, v = V(trade2007.ig)[c("China", "Canada", "United Kingdom", "Denmark")])
         China         Canada United Kingdom        Denmark 
           364            364            364            362 
```

### *Indegree* and *outdegree* calculations

||igraph|statnet|
|---|---|---|
|indegree|`igraph::degree(climate.ig,mode="in", loops = FALSE)`|`sna::degree(climate.stat, cmode="indegree")`|
|outdegree|`igraph::degree(climate.ig,mode="out", loops = FALSE)`|`sna::degree(climate.stat, cmode="outdegree")`|

Code from the tutorial to create `data.frame`s with degree statistics:

```r
#igraph:

trade2007.nodes <- data.frame(name = V(trade2007.ig)$name,
    totdegree = igraph::degree(trade2007.ig, loops = FALSE),
    indegree = igraph::degree(trade2007.ig, mode = "in", loops = FALSE),
    outdegree = igraph::degree(trade2007.ig, mode = "out", loops = FALSE))

#statnet version:

trade2007.nodes <- data.frame(name = trade2007.stat%v%"vertex.names",
    totdegree = sna::degree(trade2007.stat),
    indegree = sna::degree(trade2007.stat, cmode = "indegree"),
    outdegree = sna::degree(trade2007.stat, cmode = "outdegree"))
```
    
## Components

Shortest path length between 2 nodes: igraph `distances()` does this.

```r
distances(gotbook.ig,"Petyr Baelish","Robb Stark")
# Calculate distance using unweighted edges
distances(gotbook.ig,"Petyr Baelish","Robb Stark", weights=NA)
# list shortest paths between 2 nodes
all_shortest_paths(gotbook.ig,"Bronn","Varys", weights=NA)$res
#find average shortest path for network
average.path.length(gotbook.ig,directed=F)
```

Component structure and membership

```r
# What element are returned by components
names(igraph::components(gotbook.ig))

# Number of components
igraph::components(gotbook.ig)$no 

# Size of each component
igraph::components(gotbook.ig)$csize 

# retrieve the index of isolate nodes
# (nodes with component count of 1 from "components" above)
isolates(gotbook.stat)
# There is no direct command in igraph, but we can do this:
# Create a list of the degree of each node in the network
deg_counts <- igraph::degree(gotbook.ig, loops = FALSE)
# filter and count the nodes with 0 degrees (or any other quantity of interest)
length(deg_counts[deg_counts == 0])

# subset vertex.names attribute to get names of isolates
as.vector(gotbook.stat %v% 'vertex.names')[c(isolates(gotbook.stat))]
```

## Graph density

Note: `network.density()` (statnet) ignores edge values "at present".

```r
#get network density: igraph
graph.density(climate.ig)

## [1] 0.4117647

#get network density: statnet
network.density(climate.stat)

## [1] 0.399654
```

Adding `loops = TRUE` to `graph.density()` appears to fix the problem and gets the two packages to agree:

```r
#get network density without loops: igraph
graph.density(climate.ig, loops=TRUE)

## [1] 0.399654
```

*SO*, it's safest to always do either:
- `graph.density(climate.ig, loops=TRUE)` (igraph), OR
- `network.density(climate.stat)` (statnet)

In statnet, we can get network density with loops (nodes connecting to themselves) omitted:

```r
#get network density without loops: statnet
gden(climate.stat, diag=FALSE)

## [1] 0.3921569
```

## Network degree centralization

In `statnet`, call `centralization()` with the `degree` function and appropriate parameters for `degree` in the `cmode` argument:

```r
centralization(climate.stat, degree, cmode="indegree")
centralization(climate.stat, degree, cmode="outdegree")
centralization(climate.stat, degree, cmode="freeman") # default
```

Could also call it with other `sna` functions like `betweenness`, `closeness`

The `igraph` version uses `centr_degree()` and returns an object with several components, of which `centralization` is one:

```r
centr_degree(climate.ig, loops = FALSE, mode = "in")$centralization
centr_degree(climate.ig, loops = FALSE, mode = "out")$centralization
```

### Eigenvector centralization

`statnet` uses `evcent()` to calculate the eigenvalue centrality score for each node in the network:

```r
evcent(imf2014.stat, ignore.eval=TRUE))
```

Eigenvector centrality index for the network:

```r
centralization(imf2014.stat, evcent)
```

In `igraph`, a set of eigenvector-related information is created with `centr_eigen()`:

```r
# If the network is directed, specify "directed - T" - will not auto-detect
eigen_info <- centr_eigen(imf2014.ig, directed = T)
# Centrality score for node 3:
eigen_info[3]$vector
# Eigenveector centrality index for the network:
eigen_info$centralization
```

**The scores calculated by `igraph` and `statnet` are different. We aren't sure why.** It appears that igraph [counts incoming ties to calculate eigenvector centrality](https://stackoverflow.com/questions/21035598/what-is-evcent-returning-for-directed-graphs), and statnet [recommends using Bonachic power instead for directed networks](http://mailman13.u.washington.edu/pipermail/statnet_help/2015/002170.html).

### Bonacich Power Centrality

`igraph`:

```r
power_centrality(imf2014.ig)
```

`statnet`:

```r
bonpow(imf2014.stat)
```

Again, there appear to be some inconsistency between `igraph` and `statnet` in the calculations, with statnet apparently not incorporating weights and failing on singluar matrices. 

### Derived and Reflected Centrality

There are no library routines for these calculations. Convert the data to a matrix first:

```r
mat2014 <- as.matrix(as_adjacency_matrix(imf2014.ig, attr="weight"))
```

> To calculate the proportion of centrality that is received, we first square the adjacency matrix. The diagonal of the adjacency matrix is equal to the the square of node degree. We then divide this diagonal (sqared degree) by total sqaured indegree (calculated by rowSums) to get the proportion of received centrality.

```r
# square the adjacency matrix
mat2014sq <- t(mat2014) %*% mat2014

# Calculate the proportion of reflected centrality.
imf2014.nodes$rc <- diag(mat2014sq) / rowSums(mat2014sq)

# freplace missing values with 0
imf2014.nodes$rc <- ifelse(is.nan(imf2014.nodes$rc), 0, imf2014.nodes$rc)

# Calculate received eigenvalue centrality
imf2014.nodes$eigen.rc <- imf2014.nodes$eigen * imf2014.nodes$rc
```

> If total centraltiy is 1, then derived centrality is simply 1 - the proportion of eigenvector centrality due to received centrality.

```r
# Calculate the proportion of derived centrality.
imf2014.nodes$dc <- 1 - diag(mat2014sq) / rowSums(mat2014sq)

# replace missing values with 0
imf2014.nodes$dc <- ifelse(is.nan(imf2014.nodes$dc), 1, imf2014.nodes$dc)

# Calculate received eigenvalue centrality
imf2014.nodes$eigen.dc <- imf2014.nodes$eigen * imf2014.nodes$dc
```

